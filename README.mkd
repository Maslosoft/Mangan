This extension is an almost complete, ActiveRecord like support for MongoDB in Yii
It originally started as a fork of [MongoRecord](http://www.yiiframework.com/extension/mongorecord "MongoRecord") extension written by [tyohan](http://www.yiiframework.com/user/31/ "tyohan"), to fix some major bugs, and add full featured suite for [MongoDB](http://http://www.mongodb.org "MongoDB") developers.

Some key features:

- Support of using Class::model()->find / findAll / count / countByAttributes and other Yii ActiveRecord syntax
- Support of schema-less documents with Yii standard rules and validation features
- (almost, limited only by MongoDB 4MB limit of single document) endless document embedding/nesting
- Ready to go out-of-box *EFFICIENT* DataProvider, witch use native php db driver sort, limit and offset features for returning results!
- Records and embedded documents inherit from CModel, so you can use every class witch can handle of CModel (ie: Gii form generator)
- relation support *idea/concept/example*

*IMPORTANT: please use github version, keeping track of bug fixes and updating this download is hard to catch up*

##Requirements

I've tested it only with Yii 1.1.4
it took me long night to write this initial stage, so it may have some bugs, help with testing needed ! :)

##Basic usage

Just create a model class as You would with normal ActiveRecord.
Example model simple as standard ActiveRecord:

    class Client extends EMongoRecord {

        // this method must be implemented (its defined as abstract anyway),
        // it has to return the Mongo collection name for use with this record(s)
        public function getCollectionName()
        {
            public $personal_number;
            public $first_name;
            public $last_name;

            // this method must be implemented (its defined as abstract anyway), it have to return Mongo collection name for use with this record(s)
            public function collectionName()
            {
                return 'clients';
            }

            public function rules()
            {
                return array(
                    array('personal_number, first_name, last_name', 'required'),
                );
            }

            public function attributeLabels()
            {
                return array(
                    'personal_number'=>'PN',
                );
            }

            // EVERY model has to have this! (same as CActiveRecord child classes)
            public static function model($className=__CLASS__)
            {
                return parent::model($className);
            }
        }
    }


And this is it ! use this object just as regular ActiveRecord
for instance:

    $client = new Client;
    $client->first_name='something';
    $client->save();
    $clients = Client::model->findAll();

etc.


##Embedded documents

*IMPORTANT: Embedded documents must extend from EMongoEmbeddedDocument instead of EMongoRecord, otherwise whole thing will fail, to work*
*Note: some people reported that embedding regular EMongoRecord works as expected, but i have not tested this, more test/reports needed*

Embedded documents are almost identical as EMongoRecord you only can't save them to DB they're saved by the EMongoRecord model witch has them as an embedded (with one exception, you can save them if you will do it explicitly)
Notice: Embedded documents don have static model() method!

Lest assume we have following embedded document:

    class ClientAddress extends EMongoEmbeddedDocument
    {
        public $city;
        public $street;
        public $house;
        public $apartment;
        public $zip;

        public function rules()
        {
            return array(
                array('city, street, house', 'length', 'max'=>255),
                array('house, apartment, zip', 'length', 'max'=>10),
            );
        }

        public function attributeLabels()
        {
            return array(
                'zip'=>'Postal Code',
            );
        }
    }

Now we can add this method to our Client model from previous section:

    class Client extends EMongoRecord {

        ...

        public function embeddedDocuments()
        {
            return array(
                'address'=>'ClientAddress' // property name => embedded document class name
            );
        }

        ...
    }

Now start the fun part!

    $client = new Client;
    $client->address->city='New York';
    $client->save();

it will automatically call validation for model and all embedded documents!
You even can nest embedded documents in embedded documents, just define embeddedDocuments() method with array of another embedded documents
*IMPORTANT*: This mechanism uses recurrency, and will not handle with circular nesting, you have to use this feature with care :P


##Arrays

You easily can store arrays in DB!

**Simple arrays**

- just define a property for an array, and store an array in it

**Arrays of embedded documents**

- there is no way (that i know) where i can easily provide mechanism for this, you have to write Your own
- This is how I accomplish it for now:


add a property for your array of embedded documents
    public $addresses;

add EmbeddedArraysBehavior

    public function behaviors()
    {
        return array(
            array(
                'class'=>'ext.YiiMongoDbSuite.extra.EEmbeddedArraysBehavior',
                'arrayPropertyName'=>'addresses', // name of property
                'arrayDocClassName'=>'ClientAddress' // class name of documents in array
            ),
        );
    }

now You can do:

    $c = new Client;
    $c->addresses[0] = new ClientAddress;
    $c->addresses[0]->city='NY';
    $c->save(); // behavior will handle validation of array too

or

    $c = Client::model()->find();
    foreach($c->addresses as $addr)
    {
        echo $addr->city;
    }

##Querying


simple find first
    $object = ModelClass::model->find()

you can pass a query (which is an simple array)
    $object = ModelClass::model()->find(array('personal_number'=>12345));

for reference on how to use query array see: http://www.php.net/manual/en/mongocollection.find.php

finding multiple records
simple case by attributes:
    $records = ModelClass::model()->findAllByAttributes(array('city'=>'New York'));

findAll* methods accepts additional 3 arguments $sort, $limit and $offset refer to PHP manual for how to use them:
http://www.php.net/manual/en/class.mongocursor.php

A more advanced case:
    $records = ModelClass::model()->findAll(
        array('personal_number'=>array('$mod'=>array(10, 0))), // modulo: personal_number % 10 == 0
        array('first_name'=>1), // sort by first name ascending
        10, // limit to 10 records
        25 // offset 25 / skip first 25 matches
    );

analogical this examples also apply to count* methods and delete* methods

##Relations

**Note:**

- In NoSQL World Relations are not so obvious as in RDBMS
- Because NoSQL databases are designed for performance, there is no need of defining something more complex than correct use of find() method and indexing for fetching related records
- This is just an *idea/concept/example* you can do things in yours preferred way! this is schema-less wold, think different!
- MongoDB Documentation has a clean examples and how-to's for handling relations, *please* read them for better understanding of relations in NoSQL world

###HAS_ONE relation

just define method in yours model class (assume we have client collection, and address collection in client model
    public function address()
    {
        return Address::model()->findByAttributes(array('attribute_with_client_id'=>$this->primaryKey));
    }

###BELONGS_TO relation

define in address model
    public function client()
    {
        return Client::model()->findByPk($this->attribute_with_client_id);
    }

###HAS_MANY relation

assume we have clients and orders collection
define in client:
    public function orders()
    {
        return Client::model()->findAllByAttributes(array('client_id'=>$this->primaryKey()));
    }

###MANY_MANY

As simple as defining reverse HAS_MANY relation in orders model

##Gii support

**Model generation**

- you do not have to generate yours models, yours classes are yours models and schemas!
- Gii CAN'T generate models for you! there is no schema witch gii can exam for generation

**CRUD Generation**

- Gii is not able to generate CRUD, because by default gii expects that CRUD have to be generated for CActiveRecord child classes (EMongoRecord is not child class of CACtiveRecord)

**Forms generation**

- This is a good news, Gii can generate the worst part of developer job, forms for mongo records ;]
- When generating a form from mongo record, comment out embedded docs array, or you'll see error about array/object creation
- For embedded docs just generate forms in separed way for each one

##DataProvider

basic dataprovider returns whole collection (with efficient pagination support out-of-box)
    $dp = new EMongoRecordDataProvider('modelClassNameOrInstance');

data provider with query
    $dp = new EMongoRecordDataProvider('modelClassNameOrInstance', array(/* query array goes here */));

data provider, enable sorting (needs to be set explicit)
    $dp = new EMongoRecordDataProvider('modelClassNameOrInstance', array(/* query array goes here */), array(/* standard config array */
        'sort'=>array(
            'attributes'=>array(
                // list of sortable attributes
            )
        ),
    ));

##Setup

Add this to the *import* array in your main.cfg:
    'ext.YiiMongoDbSuite.*',

And add the component declaration:
    'mongodb'=>array(
        'class'=>'EMongoDbConnection',
        'dbName'=>'database_name',
        'fsyncFlag'=>true // whatever to use fsync flag with internal DB operations
    ),

##Special topics

**Behaviors**

- You can use existing CActiveRecordBehaviors as long as they do not mess up with CActiveRecord explicit stuff (ie. behaviors that add relation handling will fail to work with EMongoRecords)
- Behaviors may extend from EMongoRecordBehavior class, standard AR behavior class can't use extra events witch are available here (beforeEmbeddedDocsInit and afterEmbeddedDocsInit)

**Performance**

- By default all save/update/delete operations performed by internal command sets the FSYNC flag to TRUE, this means, all operations will have to wait for a disk sync!
- FSYNC in most cases is a good way and do not have massive impact on performance
- You may want to disable FSYNC flag when doing massive imports/updates/models, because it will be **horrible** slow!
- Fsync can be disabled by setting up fsyncField in EMongoDbConnection class

**Massive hand operations**

Example mass insert (you will want to disable fsyncField for this:
    for($i=0; $i<1000; $i++)
    {
        $c = new Client;
        $c->personal_number = $i;
        $c->validate(); // You can omit this if you want
        $c->getCollection()->insert($c->toArray());
    }

##Known bugs
Remember, this is not complete yet. So at this stage, it can have some ;]
If you find any please let me know

##Changelog

- Added EMongoRecordBehavior (Support for new events present in EMongoRecord)
- Added FSync control field fsyncFlag in EMongoDBConnection class (default set to true)
- Changed the way of setup, db property name change to dbName
- Added EEmbeddedArraysBehavior extra

##Resources

 * [Project page](https://github.com/canni/YiiMongoDbSuite/)
 * [MongoDB documentation](http://www.mongodb.org/display/DOCS/Home)
 * [PHP MongoDB Driver docs](http://www.php.net/manual/en/book.mongo.php)

##Contribution needed!

- I'm not English native speaker, need someone who can correct/rewrite/write my documentation and/or PHPDoc's in code
- Any help would be great :)
- Contact me: darek.krk on a gmail dot com or via PM
